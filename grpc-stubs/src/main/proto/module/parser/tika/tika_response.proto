syntax = "proto3";

package io.pipeline.parsed.data.tika.v1;

import "google/protobuf/timestamp.proto";
import "module/parser/tika/dublin_core.proto";
import "module/parser/tika/office_metadata.proto";
import "module/parser/tika/pdf_metadata.proto";
import "module/parser/tika/image_metadata.proto";
import "module/parser/tika/email_metadata.proto";
import "module/parser/tika/media_metadata.proto";
import "module/parser/tika/html_metadata.proto";
import "module/parser/tika/rtf_metadata.proto";
import "module/parser/tika/database_metadata.proto";
import "module/parser/tika/font_metadata.proto";
import "module/parser/tika/epub_metadata.proto";
import "module/parser/tika/warc_metadata.proto";
import "module/parser/tika/climate_forecast_metadata.proto";
import "module/parser/tika/creative_commons_metadata.proto";
import "module/parser/tika/generic_metadata.proto";

option java_multiple_files = true;
option java_package = "io.pipeline.parsed.data.tika.v1";
option java_outer_classname = "TikaResponseProto";

/**
 * Flexible TikaResponse that mirrors how Tika actually stores metadata.
 * Only populated fields are included, making it much more efficient.
 */
message TikaResponse {
  // Document identifier
  string doc_id = 1;
  string parse_id = 2;
  
  // Core content (always present if extraction succeeded)
  TikaContent content = 3;
  
  // Dublin Core metadata - standardized fields present in most documents
  io.pipeline.parsed.data.dublin.v1.DublinCoreMetadata dublin_core = 4;
  
  // Document-type specific metadata (only one will be populated based on doc type)
  oneof document_metadata {
    io.pipeline.parsed.data.office.v1.OfficeMetadata office = 5;
    io.pipeline.parsed.data.pdf.v1.PdfMetadata pdf = 7;
    io.pipeline.parsed.data.image.v1.ImageMetadata image = 8;
    io.pipeline.parsed.data.email.v1.EmailMetadata email = 9;
    io.pipeline.parsed.data.media.v1.MediaMetadata media = 10;
    io.pipeline.parsed.data.html.v1.HtmlMetadata html = 11;
    io.pipeline.parsed.data.rtf.v1.RtfMetadata rtf = 17;
    io.pipeline.parsed.data.database.v1.DatabaseMetadata database = 18;
    io.pipeline.parsed.data.tika.font.v1.FontMetadata font = 19;
    io.pipeline.parsed.data.epub.v1.EpubMetadata epub = 20;
    io.pipeline.parsed.data.warc.v1.WarcMetadata warc = 21;
    io.pipeline.parsed.data.climate.v1.ClimateForcastMetadata climate_forecast = 22;
    io.pipeline.parsed.data.creative_commons.v1.CreativeCommonsMetadata creative_commons = 23;
    io.pipeline.parsed.data.generic.v1.GenericMetadata generic = 24;
  }
  
  // Additional metadata as typed entries (for less common fields)
  repeated TikaMetadataEntry metadata = 12;
  
  // Parse status and statistics
  TikaParseStatus status = 13;
  
  // Raw key-value pairs for anything not captured in typed metadata
  map<string, string> raw_properties = 14;
  
  // Embedded documents if found
  repeated TikaEmbeddedDoc embedded_docs = 15;
  
  google.protobuf.Timestamp parsed_at = 16;
}

/**
 * Core content - the actual text extracted
 */
message TikaContent {
  string body = 1;
  optional string title = 2;
  optional string description = 3;
  optional string keywords = 4;
  int64 content_length = 5;
}

/**
 * Generic metadata entry for properties not covered by the strongly-typed fields.
 * Most metadata should be in the specific typed fields above.
 */
message TikaMetadataEntry {
  string key = 1;
  oneof value {
    string text = 2;
    int64 integer = 3;
    double number = 4;
    bool boolean = 5;
    google.protobuf.Timestamp date = 6;
    StringList text_list = 7;
  }
}


/**
 * String list helper
 */
message StringList {
  repeated string values = 1;
}

/**
 * Parse status
 */
message TikaParseStatus {
  enum Status {
    STATUS_UNSPECIFIED = 0;
    STATUS_SUCCESS = 1;
    STATUS_PARTIAL = 2;
    STATUS_FAILED = 3;
    STATUS_TIMEOUT = 4;
  }
  
  Status status = 1;
  int64 parse_time_ms = 2;
  string parser_used = 3;
  repeated string parsers_used = 4;
  repeated string warnings = 5;
  repeated string errors = 6;
}

/**
 * Embedded document
 */
message TikaEmbeddedDoc {
  string id = 1;
  string path = 2;
  string filename = 3;
  string content_type = 4;
  int32 embed_depth = 5;
  
  // The embedded doc can have its own parsed content
  optional TikaResponse parsed_content = 6;
}